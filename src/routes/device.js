const express = require('express');
const router = express.Router();
const Joi = require('joi');
const { authenticateDevice } = require('../middleware/auth');
const { generalRateLimit } = require('../middleware/rateLimiter');
const { validate } = require('../middleware/validation');
const sslService = require('../services/sslService');
const logger = require('../utils/logger');

// UUID generation function
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

/**
 * @route POST /api/v1/device/check
 * @desc Simple device check without database dependency
 * @access Public
 */
router.post('/check',
  validate(Joi.object({
    deviceId: Joi.string().min(1).required(),
  })),
  async(req, res) => {
    try {
      const { deviceId } = req.body;

      logger.info('Device check request', { deviceId });

      // Simple device check that doesn't require database
      // This is used by the auth page when database is unavailable
      res.json({
        success: true,
        authenticated: false, // Default to false for new devices
        deviceId,
        message: 'Device check completed. Use verify endpoint to authenticate.',
        status: 'ready_for_verification',
      });
    } catch (error) {
      logger.error('Device check failed', { error: error.message, body: req.body });
      res.json({
        success: false,
        authenticated: false,
        deviceId: req.body.deviceId,
        error: error.message,
      });
    }
  },
);

/**
 * @route POST /api/v1/device/validate-api-key
 * @desc Validate API key for Chrome extension
 * @access Public
 */
router.post('/validate-api-key',
  validate(Joi.object({
    deviceId: Joi.string().min(1).required(),
    apiKey: Joi.string().min(1).required(),
  })),
  async(req, res) => {
    try {
      const { deviceId, apiKey } = req.body;

      logger.info('API key validation request', { deviceId, apiKeyPrefix: `${apiKey.substring(0, 10)}...` });

      // Basic API key format validation
      if (!apiKey.startsWith('dev_') || apiKey.length < 20) {
        return res.json({
          success: false,
          valid: false,
          message: 'Invalid API key format',
          deviceId,
        });
      }

      // For now, just validate the format since the API key was generated by our system
      // In a production environment, you'd want to validate against the database
      res.json({
        success: true,
        valid: true,
        deviceId,
        message: 'API key is valid',
        status: 'valid',
      });
    } catch (error) {
      logger.error('API key validation failed', { error: error.message, body: req.body });
      res.json({
        success: false,
        valid: false,
        deviceId: req.body.deviceId,
        error: error.message,
      });
    }
  },
);

/**
 * @route POST /api/v1/device/status
 * @desc Get device authentication status
 * @access Public
 */
router.post('/status',
  validate(Joi.object({
    deviceId: Joi.string().min(1).required(),
  })),
  async(req, res) => {
    try {
      const { deviceId } = req.body;

      logger.info('Device status request', { deviceId });

      // Check if device is authenticated/registered
      const sslStatus = await sslService.getDeviceStatus(deviceId);

      res.json({
        success: true,
        authenticated: sslStatus.success && sslStatus.certificate && !sslStatus.certificate.expired,
        deviceId,
        sslStatus,
      });
    } catch (error) {
      logger.error('Device status check failed', { error: error.message, body: req.body });
      res.json({
        success: false,
        authenticated: false,
        deviceId: req.body.deviceId,
        error: error.message,
      });
    }
  },
);

/**
 * @route POST /api/v1/device/register
 * @desc Register a new device and get UUID device ID
 * @access Public
 */
router.post('/register',
  validate(Joi.object({
    deviceInfo: Joi.object({
      userAgent: Joi.string().optional(),
      platform: Joi.string().optional(),
      browser: Joi.string().optional(),
    }).required(),
    userPreferences: Joi.object({
      nickname: Joi.string().optional(),
    }).optional(),
  })),
  async(req, res) => {
    try {
      const { deviceInfo, userPreferences } = req.body;

      logger.info('Device registration request - FINAL RESTORE', { deviceInfo, userPreferences });

      // Generate a new UUID device ID
      const deviceId = generateUUID();

      // Register the device with SSL service
      await sslService.registerDevice(deviceId, {
        userAgent: deviceInfo.userAgent,
        platform: deviceInfo.platform,
        browser: deviceInfo.browser,
        nickname: userPreferences?.nickname,
        verified: false,
        registeredAt: new Date().toISOString(),
      });

      res.json({
        success: true,
        deviceId,
        subdomain: `${deviceId}.myl.zip`,
        message: 'Device registered successfully. Use verify endpoint to authenticate.',
        status: 'registered',
      });
    } catch (error) {
      logger.error('Device registration failed', { error: error.message, body: req.body });
      res.json({
        success: false,
        error: error.message,
      });
    }
  },
);

/**
 * @route POST /api/v1/device/verify
 * @desc Verify device and register it
 * @access Public
 */
router.post('/verify',
  validate(Joi.object({
    deviceId: Joi.string().min(1).required(),
    userAgent: Joi.string().optional(),
    platform: Joi.string().optional(),
    language: Joi.string().optional(),
  })),
  async(req, res) => {
    try {
      const { deviceId, userAgent, platform, language } = req.body;

      logger.info('Device verification request', { deviceId, userAgent, platform, language });

      // Register/verify the device
      await sslService.registerDevice(deviceId, {
        userAgent,
        platform,
        language,
        verified: true,
        verifiedAt: new Date().toISOString(),
      });

      res.json({
        success: true,
        message: 'Device verified successfully',
        deviceId,
        verified: true,
      });
    } catch (error) {
      logger.error('Device verification failed', { error: error.message, body: req.body });
      res.json({
        success: false,
        message: 'Device verification failed',
        error: error.message,
      });
    }
  },
);

// Get all devices for user
router.get('/',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    // TODO: Implement device listing
    res.json({
      success: true,
      data: {
        devices: [],
        total: 0,
        deviceId: req.device.id,
      },
    });
  },
);

// Get specific device details
router.get('/:deviceId',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId } = req.params;

    // TODO: Implement device details retrieval
    res.json({
      success: true,
      data: {
        id: deviceId,
        deviceId,
        deviceType: 'unknown',
        deviceVersion: '1.0.0',
        fingerprint: 'fingerprint-hash',
        publicKey: 'public-key',
        capabilities: [],
        isActive: true,
        lastSeen: new Date().toISOString(),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      },
    });
  },
);

// Update device information
router.put('/:deviceId',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId } = req.params;
    const { deviceType, deviceVersion, capabilities, metadata } = req.body;

    // TODO: Implement device update
    res.json({
      success: true,
      data: {
        id: deviceId,
        deviceId,
        deviceType: deviceType || 'unknown',
        deviceVersion: deviceVersion || '1.0.0',
        capabilities: capabilities || [],
        metadata: metadata || {},
        updatedAt: new Date().toISOString(),
      },
    });
  },
);

// Deactivate device
router.put('/:deviceId/deactivate',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId } = req.params;

    // TODO: Implement device deactivation
    res.json({
      success: true,
      data: {
        id: deviceId,
        deviceId,
        deactivated: true,
        deactivatedAt: new Date().toISOString(),
      },
    });
  },
);

// Reactivate device
router.put('/:deviceId/reactivate',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId } = req.params;

    // TODO: Implement device reactivation
    res.json({
      success: true,
      data: {
        id: deviceId,
        deviceId,
        reactivated: true,
        reactivatedAt: new Date().toISOString(),
      },
    });
  },
);

// Get device sessions
router.get('/:deviceId/sessions',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId } = req.params;
    const { limit = 50, offset = 0 } = req.query;

    // TODO: Implement device sessions retrieval
    res.json({
      success: true,
      data: {
        deviceId,
        sessions: [],
        total: 0,
        limit: parseInt(limit, 10),
        offset: parseInt(offset, 10),
      },
    });
  },
);

// Revoke device session
router.delete('/:deviceId/sessions/:sessionId',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId, sessionId } = req.params;

    // TODO: Implement session revocation
    res.json({
      success: true,
      data: {
        deviceId,
        sessionId,
        revoked: true,
        revokedAt: new Date().toISOString(),
      },
    });
  },
);

// Get device trust relationships
router.get('/:deviceId/trust',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId } = req.params;

    // TODO: Implement trust relationships retrieval
    res.json({
      success: true,
      data: {
        deviceId,
        trustRelationships: [],
        total: 0,
      },
    });
  },
);

// Establish trust with another device
router.post('/:deviceId/trust',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId } = req.params;
    const { targetDeviceId, trustLevel, encryptedTrustData } = req.body;

    // TODO: Implement trust establishment
    res.json({
      success: true,
      data: {
        sourceDeviceId: deviceId,
        targetDeviceId,
        trustLevel: trustLevel || 1,
        encryptedTrustData: encryptedTrustData || null,
        established: true,
        establishedAt: new Date().toISOString(),
      },
    });
  },
);

// Remove trust relationship
router.delete('/:deviceId/trust/:targetDeviceId',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId, targetDeviceId } = req.params;

    // TODO: Implement trust removal
    res.json({
      success: true,
      data: {
        sourceDeviceId: deviceId,
        targetDeviceId,
        removed: true,
        removedAt: new Date().toISOString(),
      },
    });
  },
);

// Get device capabilities
router.get('/:deviceId/capabilities',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId } = req.params;

    // TODO: Implement capabilities retrieval
    res.json({
      success: true,
      data: {
        deviceId,
        capabilities: [
          'markdown-editing',
          'file-sync',
          'encryption',
          'offline-storage',
        ],
        supportedFormats: ['md', 'txt', 'json'],
        maxFileSize: '50MB',
        syncInterval: 300,
      },
    });
  },
);

// Update device capabilities
router.put('/:deviceId/capabilities',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId } = req.params;
    const { capabilities, supportedFormats, maxFileSize, syncInterval } = req.body;

    // TODO: Implement capabilities update
    res.json({
      success: true,
      data: {
        deviceId,
        capabilities: capabilities || [],
        supportedFormats: supportedFormats || [],
        maxFileSize: maxFileSize || '50MB',
        syncInterval: syncInterval || 300,
        updatedAt: new Date().toISOString(),
      },
    });
  },
);

// Get device statistics
router.get('/:deviceId/stats',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId } = req.params;

    // TODO: Implement device statistics
    res.json({
      success: true,
      data: {
        deviceId,
        totalSyncs: 0,
        successfulSyncs: 0,
        failedSyncs: 0,
        lastSyncTime: null,
        averageSyncTime: 0,
        totalDataTransferred: '0MB',
        uptime: '0 hours',
      },
    });
  },
);

// Ping device (update last seen)
router.post('/:deviceId/ping',
  authenticateDevice,
  generalRateLimit,
  (req, res) => {
    const { deviceId } = req.params;

    // TODO: Implement device ping
    res.json({
      success: true,
      data: {
        deviceId,
        pinged: true,
        timestamp: new Date().toISOString(),
        responseTime: Math.random() * 100 + 10, // Mock response time
      },
    });
  },
);

/**
 * @route POST /api/v1/device/generate-key
 * @desc Generate API key for device with UUID subdomain SSL certificate
 * @access Private (Device Registration Required)
 */
router.post('/generate-key',
  validate(Joi.object({
    deviceId: Joi.string().min(1).required(),
    deviceName: Joi.string().min(1).required(),
    userInitials: Joi.string().min(1).required(),
  })),
  async(req, res) => {
    try {
      const { deviceId, deviceName, userInitials } = req.body;

      logger.info('Device API key generation request', { deviceId, deviceName, userInitials });

      // Verify device has UUID subdomain SSL certificate
      const sslStatus = await sslService.getDeviceStatus(deviceId);
      if (!sslStatus.success || !sslStatus.certificate || sslStatus.certificate.expired) {
        return res.apiError('Device must have a valid UUID subdomain SSL certificate to generate API key', 403);
      }

      // Generate device-specific API key
      const result = await sslService.generateDeviceApiKey(deviceId, {
        deviceName,
        userInitials,
        permissions: ['ssl:read', 'device:read', 'api:access'],
      });

      res.apiSuccess(result, 'Device API key generated successfully');
    } catch (error) {
      logger.error('Device API key generation failed', { error: error.message, body: req.body });
      res.apiError('Failed to generate device API key', 500, error.message);
    }
  },
);

module.exports = router;
